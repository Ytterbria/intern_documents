RabbitMQ作为消息中间件,承担者异步解耦,削峰填谷的重要角色,
如果挂了会导致整体业务系统不可用,所以要保证Broker和消息的高可用
让某个节点挂了也能继续服务,并且消息不回因为单个节点宕机而丢失

*模式高可用
.集群模式 Cluster
集群由多个Broker节点组成,共享meta data(用户,虚拟主机,交换机,队列定义等)
队列的消息默认存储在单个节点,而不是所有节点,如果存放的节点宕机,则该队列不可用
所以这种模式只保证了管理高可用,没有保证消息高可用

.镜像队列 Mirrored Queue
仿照kafka的主从模式
解决了集群模式下的消息丢失问题,队列的数据会复制到多个节点(一个master,多个slave)
消费者连接时,会自动路由到master节点,slave作为备份
master挂了,slave会升级为新的master

.仲裁队列 Quorum Queue
类似Raft一致性协议,通过多事派投票来保证数据一致性,不像镜像队列的全量复制
而是更搞笑的副本机制.  适合高可靠场景(金融,订单),性能更稳定,避免了镜像队列带来的脑裂问题



*Raft
.Raft中有三种角色: 
leader: 唯一的领导者,负责处理客户端请求和日志复制
follower: 被动响应,接受leader的日志同步
candidate: 选举时,follower超时没收到心跳会变成candidate

.心跳选举: 
如果follower长时间没有收到来自leader的心跳(leader宕机),
则follower会变成candidate,并且发起投票,候选人会向其他节点请求投票,如果超过半数投票,则当选leader, leader需要定期发送心跳包(AppendEntries RPC)来证明自己还活着

.日志复制流程
1.客户端发送写请求 -> leader追加日志条目(未提交,先写日志再提交)
2.Leader将日志复制到所有Follower
3.当超过半数的节点写入成功 -> 日志提交成功
4.Leader通知所有follower提交日志. 这样就保证了多数派写成功 -> 数据一致

.安全性保证
任期号: 每次选举产生新的term,防止旧的Leader篡改数据
投票规则: 只有拥有最新的日志的节点才能赢得选举
日志匹配原则: 新的Leader必须保证日志和多数节点保持一致


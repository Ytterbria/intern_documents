*存储方式
redis所有的数据都存储在内存中,而不是磁盘,内存访问速度纳秒级别
磁盘访问速度是微秒级别,所以,访问速度快了千倍左右
只有少数场景例如持久化才会需要与磁盘交互


*线程设计
redis采用了单个线程执行命令,不需要线程切换,避免了上下文切换带来的性能开销
采用了多路IO复用的技术,单个线程可以同时处理多个客户端连接,提高了redis的并发能力

也不只是单线程,redis4.0之后,引入了unlink命令,可以执行异步删除等操作. 
redis6.0之后,引入了多线程机制,利用多线程的机制并发处理网络请求,减少网络IO的瓶颈


*I/O 模型设计:
.同步阻塞: 当线程调用read时候,如果数据还没到来,线程就会一直阻塞等待, 数据从网卡到内核,再从内核拷贝到用户空间,这两个拷贝过程都称作 阻塞操作

.同步非阻塞: 非阻塞模式下,read调用如果没有数据,就会立即返回错误(或特定状态),不会阻塞线程. 应用程序需要不断轮询判断数据是否就绪,但是当数据拷贝到用户空间时仍然是阻塞的. 这种轮询会频繁进行系统调用,上下文切换开销大,CPU占用高,不适合大规模连接

.I/O多路复用:
通过一个线程使用select,poll,epoll等系统调用,监控多个连接的状态,只有当某个连接的数据就绪时,系统才会通知应用程序,再由应用程序调用read进行数据读取(读取时仍未阻塞操作)
select 每次调用都要重新构建和检查文件描述符
poll类似select,但是用动态数组存储文件描述符,没有限制
epoll是最终优化,提供了边缘触发和水平触发模式,不会遍历所有,而是通过事件通知


.异步I / O 
调用 aio_read后,内核负责将数据从网卡拷贝到用户空间,拷贝完成后通过回掉通知应用程序,整个过程没有阻塞. 编程模型负责,错误处理和状态管理难,开发成本高.


*数据结构
SDS simple简单动态字符串, 不同于C中的字符串,SDS可以支持自动扩展内存,
并且通常还会额外预留一部分空间,减少频繁的内存分配操作. 避免了内存分配的开销

ziplist 压缩列表 是redis中国呢列表和哈希表的底层数据结构之一
当列表或者哈希表的数据量较小且元素长度较短时,会选择使用压缩列表来存储数据
ziplist特点:
.内存紧凑: 压缩列表将所有的元素都紧凑地存储在一段连续的内存空间中,没有指针等额外的开销,每个元素都有一个前向编码和后向编码,指示前一个元素的长度,这样就可以进行快速的前后遍历,避免了指针的开销
.灵活性: 压缩列表根据存储的元素长度动态调整编码方式. 更加节省内存
.性能与空间的平衡: 当列表或哈希表变得很大时,redis会自动切换成更高效的链表和哈希表


当应用需要更新数据信息时,通常有两份数据需要保持一致: redis的缓存数据,DB的持久存储数据

由于并发,网络延迟等原因,DB可能和redis不一致,例如DB更新了,但是没有及时更新redis,
或者更新了redis,但是DB回滚了. 还有比如并发请求导致的缓存脏数据

*常见的写策略
1. update DB -> update redis
如果更新DB成功了,但是更新redis失败,redis中就会是脏数据,读请求拿到的是错误值
2. update redis -> update DB 
如果redis更新成功但是DB更新失败,缓存就是脏数据,因为DB是权威数据源
3. delete redis -> update DB 
如果DB没有完成更新的时候,期间有并发的读请求,就会先查缓存,但是此时查到的是还没有更新的脏数据,然后脏数据会被写回缓存,导致缓存污染
4. update DB -> delete redis
即使缓存删除失败,最多就是读到旧的缓存值,下次查的时候,还能回查DB更新
 
*双写一致性解决方案
1.延迟双删
update DB -> delete redis -> sleep -> delete redis
第一次删除,避免读到旧值,第二次延迟删除解决第一次删除期间,其他线程并发读写回来的旧缓存,
降低读到旧值的概率

2.消息队列异步删除缓存,写DB后,发送消息到MQ,消费者异步删除redis. 
但是系统复杂度较高,开发成本提升
3.订阅Binlog方式
应用只更新DB,不操作redis,Cannel等中间件订阅mysql binlog日志
binlog捕获变更日志过后,异步更新/删除 redis. 
4.分布式锁(互斥更新缓存)
写时加锁 或 读为空时加锁
对更新缓存的操作加上Redisson,确保同一个时刻只有一个线程能写缓存
性能下降,适合一致性要求极高的场景. 



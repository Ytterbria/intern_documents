不设置过期,数据会无限增长,导致内存爆炸,所以数据一定要设置TTL
*常见几种过期策略
1.定时删除
设置过期时间时时,Redis会创建一个定时器,到时间自动删除
这样内存能及时释放,一过期就能保证立马被删除. 但是会增加CPU开销,
定时器太多了会影响性能. 一般不采用纯定时
2.惰性删除(被动,访问时删除)
当访问key时,redis才检查它是否过期,如果过期了则删除并返回不存在,否则正常返回
这种策略会导致有些低频key总是不被访问,导致内存占用. 
而只在访问时检查, CPU的开销小
3.定期删除(主动,随机采样)
redis每隔一段时间,随机抽取一些设置了TTL的key,检查并删除expired key.
不是全量扫描,避免了阻塞,但是依赖采样概率,还是可能一部分过期key迟迟没有被删除

一般是几种,采用的是惰性删除 + 定期删除. 兼顾了定时删除的高CPU开销,
也避免了惰性删除带来的内存泄漏.


*内存淘汰策略
即使有过期的策略,但是也可能因为数据量太大而撑爆了内存
所以当内存达到上限时,需要有合理的内存淘汰策略
常见策略: (两个关键词搭配)
.noeviction(default): 内存满后,不再写入新数据,只返回错误

key 范围: volatile: 在设置了ttl的key中选择删除. allkeys: 所有的key中选择
删除策略: lru(删除最久未使用的) random (随机删除),ttl(删除剩余时间最短的)


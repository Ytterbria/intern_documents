å¤ªå¥½äº†ï¼ä¸‹é¢æˆ‘æŒ‰â€œæœ€å°å¯ç”¨â†’å¯æ‰©å±•â€çš„æ€è·¯ï¼Œ**æ‰‹æŠŠæ‰‹**å¸¦ä½ å®ç°ä¸€ä¸ªå¯è·‘çš„ Python Agent é¡¹ç›®ï¼Œå¹¶åœ¨æœ€åç»™å‡ºâ€œæ¥ Redis / MySQLâ€çš„æ‰©å±•ç‚¹ã€‚æˆ‘ä»¬ç›´æ¥åŸºäºä½ ç°åœ¨çš„é¡¹ç›®ç»§ç»­æ­å»ºã€‚

---

# æ­¥éª¤ 0ï½œå®‰è£…æ‰€éœ€ä¾èµ–

æœ¬ demo åªä¾èµ–æ ‡å‡†åº“ + `fastapi` + `uvicorn` + `httpx` + `python-dotenv`ï¼ˆç”¨äºè¯»å– `.env`ï¼‰ï¼Œä¸å¼ºä¾èµ– langchainï¼Œç»“æ„æ›´æ¸…æ™°ã€‚

```bash
poetry add httpx python-dotenv
```

> ä½ ä¹‹å‰å·²ç»æœ‰ `fastapi`ã€`uvicorn`ã€‚å¦‚æœæ²¡æœ‰ï¼š
> `poetry add fastapi uvicorn`

---

# æ­¥éª¤ 1ï½œé¡¹ç›®ç»“æ„ï¼ˆåœ¨ç°æœ‰åŸºç¡€ä¸Šæ–°å¢å‡ ä¸ªæ–‡ä»¶å¤¹ï¼‰

```
copylot/
â”œâ”€â”€ app.py                      # FastAPI å…¥å£ï¼ˆå·²æœ‰ï¼‰
â”œâ”€â”€ config.py                   # é…ç½®ï¼ˆå·²æœ‰ï¼Œå¯æ›¿æ¢ä¸ºä¸‹æ–‡ç‰ˆæœ¬ï¼‰
â”œâ”€â”€ models.py                   # Pydantic è¯·æ±‚/å“åº”æ¨¡å‹ï¼ˆå·²æœ‰ï¼Œå¯è¦†ç›–ï¼‰
â”œâ”€â”€ copylot/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py                 # å¯å¿½ç•¥
â”‚   â”œâ”€â”€ agent/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ core.py             # Agent ä¸»é€»è¾‘ï¼ˆæ–°å¢ï¼‰
â”‚   â”‚   â””â”€â”€ tools/
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ sql_parser.py   # ç¤ºä¾‹ Toolï¼ˆæ–°å¢ï¼‰
â”‚   â”‚       â””â”€â”€ python_help.py  # ç¤ºä¾‹ Toolï¼ˆè°ƒç”¨LLMï¼‰ï¼ˆæ–°å¢ï¼‰
â”‚   â”œâ”€â”€ llm/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ deepseek_client.py  # DeepSeek è°ƒç”¨å°è£…ï¼ˆæ–°å¢ï¼‰
â”‚   â””â”€â”€ storage/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ memory.py           # ä¼šè¯ä¸Šä¸‹æ–‡ Memory å­˜å‚¨ï¼ˆå…ˆç”¨å†…å­˜ï¼Œåé¢æ•™ä½ æ¢ Redisï¼‰
â”œâ”€â”€ .env                        # ç¯å¢ƒå˜é‡ï¼ˆæ–°å¢ï¼‰
â””â”€â”€ pyproject.toml
```

---

# æ­¥éª¤ 2ï½œé…ç½®ä¸ç¯å¢ƒå˜é‡

## `config.py`ï¼ˆè¦†ç›–ä¸ºä¸‹æ–‡ç‰ˆæœ¬ï¼‰

```python
# config.py
import os
from dotenv import load_dotenv

load_dotenv()

# --- LLM / DeepSeek ---
LLM_BASE_URL = os.getenv("LLM_BASE_URL", "https://api.deepseek.com")
LLM_API_KEY = os.getenv("LLM_API_KEY", "")           # å¿…å¡«ï¼šä½ çš„ DeepSeek Key
LLM_MODEL   = os.getenv("LLM_MODEL", "deepseek-chat")

# --- Memory / ä¼šè¯å†å² ---
HISTORY_MAX_TURNS = int(os.getenv("HISTORY_MAX_TURNS", "8"))

# --- å¯é€‰ï¼šRedis / MySQL é¢„ç•™ï¼ˆåç»­æ‰©å±•ç”¨ï¼‰---
REDIS_URL    = os.getenv("REDIS_URL", "")            # ä¾‹å¦‚ï¼šredis://localhost:6379/0
DATABASE_URL = os.getenv("DATABASE_URL", "")         # ä¾‹å¦‚ï¼šmysql+pymysql://user:pwd@host:3306/dbname
```

## `.env`ï¼ˆæ–°å»ºï¼‰

```dotenv
LLM_API_KEY=ä½ çš„_DeepSeek_API_KEY
LLM_MODEL=deepseek-chat
LLM_BASE_URL=https://api.deepseek.com
HISTORY_MAX_TURNS=8
# REDIS_URL=redis://localhost:6379/0
# DATABASE_URL=mysql+pymysql://user:pwd@localhost:3306/agent_demo
```

> **å®‰å…¨æç¤º**ï¼š`.env`ä¸è¦æäº¤åˆ°ä»“åº“ã€‚

---

# æ­¥éª¤ 3ï½œLLM å®¢æˆ·ç«¯å°è£…ï¼ˆDeepSeekï¼‰

## `copylot/llm/deepseek_client.py`

```python
# copylot/llm/deepseek_client.py
from typing import List, Dict, AsyncGenerator, Optional
import httpx

class DeepSeekClient:
  def __init__(self, api_key: str, base_url: str = "https://api.deepseek.com"):
    self.api_key = api_key
    self.base_url = base_url.rstrip("/")

  async def acomplete(
    self,
    messages: List[Dict[str, str]],
    model: str = "deepseek-chat",
    temperature: float = 0.2,
    stream: bool = False,
    timeout: Optional[float] = 30.0,
  ) -> str | AsyncGenerator[str, None]:
    url = f"{self.base_url}/chat/completions"
    payload = {"model": model, "messages": messages, "temperature": temperature, "stream": stream}

    async with httpx.AsyncClient(timeout=timeout) as client:
      headers = {"Authorization": f"Bearer {self.api_key}"}
      if not stream:
        r = await client.post(url, headers=headers, json=payload)
        r.raise_for_status()
        data = r.json()
        return data["choices"][0]["message"]["content"]

      # streaming
      r = await client.post(url, headers=headers, json=payload)
      r.raise_for_status()

      async def _stream():
        async for line in r.aiter_lines():
          if not line or not line.startswith("data: "):
            continue
          if line.strip() == "data: [DONE]":
            break
          chunk = line.removeprefix("data: ").strip()
          try:
            obj = httpx.Response(200, text=chunk).json()
          except Exception:
            continue
          delta = obj.get("choices", [{}])[0].get("delta", {}).get("content", "")
          if delta:
            yield delta
      return _stream()
```

---

# æ­¥éª¤ 4ï½œæœ€ç®€å•çš„ä¼šè¯è®°å¿†ï¼ˆå…ˆç”¨å†…å­˜ï¼‰

## `copylot/storage/memory.py`

```python
# copylot/storage/memory.py
from collections import defaultdict
from typing import List, Dict
from config import HISTORY_MAX_TURNS

class InMemoryStore:
  def __init__(self):
    # session_id -> list[{"role": "...", "content": "..."}]
    self._store: Dict[str, List[Dict[str, str]]] = defaultdict(list)

  def get_history(self, session_id: str) -> List[Dict[str, str]]:
    return self._store.get(session_id, [])

  def append(self, session_id: str, role: str, content: str):
    self._store[session_id].append({"role": role, "content": content})
    # é™åˆ¶é•¿åº¦ï¼ˆä¿ç•™æœ€è¿‘ N è½®ï¼‰
    if len(self._store[session_id]) > 2 * HISTORY_MAX_TURNS:
      self._store[session_id] = self._store[session_id][-2 * HISTORY_MAX_TURNS :]
`````

> ä¹‹åä½ å¯ä»¥æŠŠè¿™é‡Œæ›¿æ¢æˆ Redisï¼ˆæˆ‘åœ¨æ–‡æœ«ç»™å‡ºæ›¿æ¢ä»£ç ï¼‰ã€‚

---

# æ­¥éª¤ 5ï½œä¸¤ä¸ªç¤ºä¾‹ Toolï¼ˆSQL è§£æ & Python å¸®åŠ©ï¼‰

## `copylot/agent/tools/sql_parser.py`

```python
# copylot/agent/tools/sql_parser.py
import re
from typing import Set

def extract_table_names(sql: str) -> Set[str]:
  tables: Set[str] = set()
  # 1) åŒ¹é… FROM ... / JOIN ...
  for kw in ["from", "join"]:
    pattern = re.compile(rf"\b{kw}\s+([`\"\[\]\w\.]+)", re.IGNORECASE)
    for m in pattern.finditer(sql):
      tables.add(m.group(1))
  # 2) ç®€å• insert into
  m2 = re.finditer(r"\binsert\s+(?:overwrite\s+)?(?:into\s+)?(?:table\s+)?([`\"\[\]\w\.]+)", sql, re.IGNORECASE)
  for m in m2:
    tables.add(m.group(1))
  # 3) å»æ‰å¼•å·ã€[]ã€`
  norm = set()
  for t in tables:
    x = t.strip().strip("`").strip('"').strip("[").strip("]")
    norm.add(x)
  return norm
```

## `copylot/agent/tools/python_help.py`

```python
# copylot/agent/tools/python_help.py
from typing import List, Dict
from copylot.llm.deepseek_client import DeepSeekClient

PY_HELP_SYSTEM = (
  "You are a Python data/dev assistant. "
  "Answer with short, actionable steps and minimal code examples."
)

class PythonHelpTool:
  def __init__(self, llm: DeepSeekClient, model: str):
    self.llm = llm
    self.model = model

  async def run(self, question: str, history: List[Dict[str, str]]) -> str:
    messages = [{"role": "system", "content": PY_HELP_SYSTEM}]
    # å¸¦ä¸€ç‚¹ä¸Šä¸‹æ–‡
    messages.extend(history[-6:])
    messages.append({"role": "user", "content": question})
    return await self.llm.acomplete(messages, model=self.model, temperature=0.2, stream=False)
```

---

# æ­¥éª¤ 6ï½œAgent ä¸»é€»è¾‘ï¼ˆè·¯ç”± â†’ è°ƒç”¨ä¸åŒ Tool â†’ å†™å…¥ä¼šè¯ï¼‰

## `copylot/agent/core.py`

```python
# copylot/agent/core.py
from typing import Dict
from copylot.storage.memory import InMemoryStore
from copylot.agent.tools.sql_parser import extract_table_names
from copylot.agent.tools.python_help import PythonHelpTool

class RouterAgent:
  def __init__(self, store: InMemoryStore, py_tool: PythonHelpTool):
    self.store = store
    self.py_tool = py_tool

  async def ask(self, session_id: str, question: str) -> Dict[str, str]:
    # 1) å–å†å²
    history = self.store.get_history(session_id)

    # 2) ç®€å•è·¯ç”±è§„åˆ™
    q_lower = question.lower().strip()

    # æ˜¾å¼æ¨¡å¼ï¼šsql: å¼€å¤´ â†’ SQL å·¥å…·
    if q_lower.startswith("sql:"):
      sql = question[4:].strip()
      tables = extract_table_names(sql)
      answer = f"è§£æåˆ°çš„è¡¨: {', '.join(tables) if tables else '(æœªè¯†åˆ«)'}"
    else:
      # é»˜è®¤ â†’ Python å¸®åŠ©ï¼ˆLLMï¼‰
      answer = await self.py_tool.run(question, history)

    # 3) å†™å†å²
    self.store.append(session_id, "user", question)
    self.store.append(session_id, "assistant", answer)

    return {"answer": answer}
```

---

# æ­¥éª¤ 7ï½œè¯·æ±‚/å“åº”æ¨¡å‹

## `models.py`ï¼ˆè¦†ç›–ä¸ºä¸‹æ–‡ç‰ˆæœ¬ï¼‰

```python
# models.py
from pydantic import BaseModel, Field

class AskRequest(BaseModel):
  session_id: str = Field(..., description="ä¼šè¯IDï¼Œç”¨äºå¤šè½®å¯¹è¯")
  question: str  = Field(..., description="ç”¨æˆ·é—®é¢˜")

class AskResponse(BaseModel):
  answer: str
```

---

# æ­¥éª¤ 8ï½œFastAPI å…¥å£ï¼ˆæ¥å‰ç«¯/æµ‹è¯•ï¼‰

## `app.py`ï¼ˆè¦†ç›–ä¸ºä¸‹æ–‡ç‰ˆæœ¬ï¼‰

```python
# app.py
from fastapi import FastAPI
from models import AskRequest, AskResponse
from config import LLM_API_KEY, LLM_BASE_URL, LLM_MODEL
from copylot.storage.memory import InMemoryStore
from copylot.llm.deepseek_client import DeepSeekClient
from copylot.agent.python_help import PythonHelpTool  # alias path fix
from copylot.agent.core import RouterAgent

# ä¿®æ­£å¯¼å…¥è·¯å¾„ï¼ˆpython_help åœ¨ tools ä¸‹ï¼‰
from copylot.agent.tools.python_help import PythonHelpTool as _PythonHelpTool

app = FastAPI(title="Copylot Agent Demo", version="0.1.0")

# --- ä¾èµ–è£…é… ---
store = InMemoryStore()
llm   = DeepSeekClient(api_key=LLM_API_KEY, base_url=LLM_BASE_URL)
py_tool = _PythonHelpTool(llm=llm, model=LLM_MODEL)
agent = RouterAgent(store=store, py_tool=py_tool)

@app.get("/healthz")
async def healthz():
  return {"status": "ok"}

@app.post("/ask", response_model=AskResponse)
async def ask(req: AskRequest):
  result = await agent.ask(session_id=req.session_id, question=req.question)
  return AskResponse(**result)
```

> æ³¨æ„ä¸Šé¢ä¸¤è¡Œå¯¼å…¥ï¼š
> `from copylot.agent.python_help import PythonHelpTool` æ˜¯è¯¯å¯¼è·¯å¾„ï¼›çœŸæ­£æ–‡ä»¶åœ¨ `tools/` ä¸‹ï¼Œæ‰€ä»¥æ¥ç€ç”¨äº†ï¼š
> `from copylot.agent.tools.python_help import PythonHelpTool as _PythonHelpTool`
> ä¹Ÿå¯ä»¥ç›´æ¥åˆ æ‰ç¬¬ä¸€è¡Œè¯¯å¯¼å¯¼å…¥ã€‚

---

# æ­¥éª¤ 9ï½œè¿è¡Œä¸æµ‹è¯•

```bash
uvicorn app:app --reload
```

æµ‹è¯•ï¼ˆä»»æ„ä¸€ä¸ªï¼‰ï¼š

```bash
# èµ° LLMï¼ˆPython åŠ©æ‰‹ï¼‰
curl -X POST http://127.0.0.1:8000/ask \
  -H "Content-Type: application/json" \
  -d '{"session_id":"s1","question":"pandasæ€ä¹ˆæŠŠä¸¤åˆ—ç›¸åŠ å¾—åˆ°æ–°åˆ—ï¼Ÿ"}'

# èµ° SQL å·¥å…·ï¼ˆæœ¬åœ°è§£æè¡¨åï¼Œä¸è°ƒç”¨ LLMï¼‰
curl -X POST http://127.0.0.1:8000/ask \
  -H "Content-Type: application/json" \
  -d '{"session_id":"s1","question":"sql: select * from db.users u join orders o on u.id=o.uid"}'
```

---

# å¯é€‰è¿›é˜¶ Aï½œæŠŠå†…å­˜ä¼šè¯æ¢æˆ Redis

å®‰è£…ï¼š

```bash
poetry add redis
```

æ–°æ–‡ä»¶ `copylot/storage/redis_store.py`ï¼š

```python
# copylot/storage/redis_store.py
import json
from typing import List, Dict
import redis

class RedisStore:
  def __init__(self, url: str, prefix: str = "sess:"):
    self.r = redis.from_url(url, decode_responses=True)
    self.prefix = prefix

  def _key(self, session_id: str) -> str:
    return f"{self.prefix}{session_id}"

  def get_history(self, session_id: str) -> List[Dict[str, str]]:
    key = self._key(session_id)
    items = self.r.lrange(key, 0, -1)
    return [json.loads(x) for x in items]

  def append(self, session_id: str, role: str, content: str):
    key = self._key(session_id)
    self.r.rpush(key, json.dumps({"role": role, "content": content}))
    # ä¹Ÿå¯åœ¨è¿™é‡Œåšé•¿åº¦è£å‰ª
```

åœ¨ `app.py` é‡Œæ›¿æ¢è£…é…ï¼š

```python
from config import REDIS_URL
from copylot.storage.memory import InMemoryStore
# from copylot.storage.redis_store import RedisStore  # å¼€å¯ Redis æ—¶ç”¨å®ƒ

# ...
store = InMemoryStore()  # é»˜è®¤
# if REDIS_URL:
#   store = RedisStore(REDIS_URL)
```

---

# å¯é€‰è¿›é˜¶ Bï½œæŠŠå¯¹è¯æŒä¹…åŒ–åˆ° MySQLï¼ˆSQLAlchemyï¼‰

å®‰è£…ï¼š

```bash
poetry add sqlalchemy pymysql
```

ç®€åŒ–ç¤ºä¾‹ï¼ˆåŒæ­¥æ–¹å¼ï¼‰ï¼š

```python
# copylot/storage/db.py
from sqlalchemy import create_engine, text
from config import DATABASE_URL

engine = create_engine(DATABASE_URL, pool_pre_ping=True, future=True)

def save_message(conversation_id: str, role: str, content: str):
  with engine.begin() as conn:
    conn.execute(
      text("INSERT INTO conversation_history(conversation_id, role, content) VALUES (:cid, :role, :content)"),
      {"cid": conversation_id, "role": role, "content": content}
    )
```

è¡¨ç»“æ„ï¼ˆMySQLï¼‰ï¼š

```sql
CREATE TABLE conversation_history (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  conversation_id VARCHAR(64) NOT NULL,
  role VARCHAR(16) NOT NULL,       -- user/assistant/system
  content TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

ä½ å¯ä»¥åœ¨ `RouterAgent.ask()` å†™å…¥ DBï¼ˆä¸ Memory/Redis å¹¶å­˜ï¼‰ï¼š

```python
# è¿½åŠ ï¼š
# from copylot.storage.db import save_message
# save_message(session_id, "user", question)
# save_message(session_id, "assistant", answer)
```

---

# ä½ ç°åœ¨å­¦åˆ°çš„å…³é”®ç‚¹

1. **æ¸…æ™°åˆ†å±‚**ï¼š`llm`ï¼ˆæ¨¡å‹è°ƒç”¨ï¼‰ã€`agent`ï¼ˆå†³ç­–/å·¥å…·è·¯ç”±ï¼‰ã€`tools`ï¼ˆå¯æ’æ‹”èƒ½åŠ›ï¼‰ã€`storage`ï¼ˆä¸Šä¸‹æ–‡/æŒä¹…åŒ–ï¼‰ã€`api`ï¼ˆFastAPI æš´éœ²æ¥å£ï¼‰ã€‚
2. **æœ€å°å¯ç”¨**ï¼šå…ˆæŠŠâ€œé—®ç­”â†’è¿”å›â€è·‘é€šï¼Œå†é€æ­¥æ¥å…¥ Redis/MySQLã€æµå¼å“åº”ã€æƒé™éªŒè¯ã€é‡è¯•ä¸è¶…æ—¶ç­‰ã€‚
3. **æ¸è¿›å¼å¼•å…¥å¤æ‚åº¦**ï¼šç°åœ¨æ˜¯æ‰‹å†™è½»é‡ Agentï¼Œç­‰ä½ ç†Ÿæ‚‰åå†å¼•å…¥ LangChain / LangGraph åšå¤æ‚ä»»åŠ¡ç¼–æ’ã€‚

---

è¦ä¸è¦æˆ‘å†å¸®ä½ åŠ ä¸€ç‰ˆã€Œ**æµå¼è¾“å‡ºï¼ˆSSEï¼‰**ã€çš„ `/ask/stream` æ¥å£ï¼Œæˆ–ã€Œ**å·¥å…·å†å¤šä¸€ç‚¹ï¼ˆå¦‚ï¼šè¿è¡Œä¸€ä¸ªæœ¬åœ° Python ä»£ç ç‰‡æ®µï¼‰**ã€ï¼Ÿåªè¦ä½ è¯´è¦ï¼Œæˆ‘å°±æŠŠä»£ç ç»™é½ ğŸ‘‡

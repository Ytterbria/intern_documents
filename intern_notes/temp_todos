class Solution {
    public int jump(int[] nums) {
        int steps = 0;       // 记录跳跃次数
        int end = 0;         // 当前跳跃的边界
        int farthest = 0;    // 当前能跳到的最远位置

        // 注意：最后一个位置不用再跳
        for (int i = 0; i < nums.length - 1; i++) {
            farthest = Math.max(farthest, i + nums[i]);
            if (i == end) {       // 到达当前跳跃的边界
                steps++;
                end = farthest;   // 更新下一次跳跃的边界
            }
        }
        return steps;
    }
}

class Solution {
    public int longestConsecutive(int[] nums) {
        
        if (nums.length == 0) {
            return 0;
        }
    Arrays.sort(nums);
    int max = 1,res = 1;
    for (int i = 1;i < nums.length;i ++)
    {
        if (nums[i]-nums[i-1]==0){
            continue;
        }
        if (nums[i]-nums[i-1] == 1){
            max ++ ;
            res = Math.max(max,res);
        }else {
            max = 1;
        }
    }
    return res;
    }
}